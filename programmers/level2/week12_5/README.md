## ìƒˆë¡œ ë°°ìš°ê²Œ ëœ ë‚´ìš©ë“¤ âœğŸ“š

### 1. í”¼ë³´ë‚˜ì¹˜ ìˆ˜ë¥¼ êµ¬í•˜ëŠ” 3ê°€ì§€ ë°©ë²•!ğŸ˜¶
1. ì¬ê·€ O(2^n)
2. ë™ì  í”„ë¡œê·¸ë˜ë° O(n^2)
3. ë°˜ë³µ O(n)

- ì¬ê·€ì™€ ë™ì ì€ ì—°ì† í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ëŠ” ë°©ì‹ìœ¼ë¡œ stack overflowê°€ ë‚  í™•ë¥ ì´ ë†’ê³ , ë°ì´í„°ì˜ í¬ê¸°ê°€ ê¸°í•˜ê¸‰ìˆ˜ì ìœ¼ë¡œ ì»¤ì§„ë‹¤
- ì‹¤í–‰ì‹œê°„ì€ ì¬ê·€ > ë™ì  > ë°˜ë³µ
- ê°€ì¥ ì•ˆì „í•˜ê³  ë¹ ë¥¸ ë°©ë²•ì€ â­**ë°˜ë³µ**ìœ¼ë¡œ êµ¬í•˜ëŠ” ê²ƒ!
<br/>

#### 1) ì¬ê·€
```c++
int fibo_recursion(int n) {
  if (n == 0) return 0;
  else if (n == 1) return 1;
  
  return fibo(n-1) + fibo(n-2);
}
```
<br/>

#### 2) ë™ì  í”„ë¡œê·¸ë˜ë°
```c++
double fibo_dynamic(int n) {
  if (fibo[n] != -1) return fibo[n];                   // ì´ˆê¸°í™” ë˜ì–´ìˆëŠ” ë°°ì—´ fibo
  
  fibo[n] = fibo_dynamic(n-1) + fibo_dynamic(n-2);
  return fibo[n];
}
```
<br/>

#### 3) ë°˜ë³µ
```c++
double fibo_while(int n) {
  for (int i = 2; i <= n; i++) {
    fibo[n] = fibo[n-1] + fibo[n-2]; 
  }
  
  return fibo[n];
}
```
<br/>

### 2. ëª¨ë“ˆëŸ¬ ì—°ì‚°
- ê³„ì‚° ê²°ê³¼ê°€ í•­ìƒ 0 - (m-1) ë²”ìœ„ì—ìˆëŠ” ê²½ìš° ëª¨ë“ˆëŸ¬ ì—°ì‚° ì‚¬ìš©
- ì´ë•Œ mì€ %ë¥¼ í•˜ê³ ì í•˜ëŠ” modular ê°’
- mì´ ìŒìˆ˜ ì¼ ë•ŒëŠ”, ì–‘ìˆ˜ë¡œ ë°”ê¿”ì„œ mod í•˜ê³  +mì„ í•´ì£¼ë©´ ëœë‹¤ (ex. -20 mod 11 == 20 => 20 mod 11 = 9, -9 + 11 = 2)
<br/>

#### 1) ëª¨ë“ˆëŸ¬ í•©ë™
- **(a mod n) = (b mod n)  ->  a â‰¡ b(mod n)**
- ì–´ë–¤ ê°’ Aì™€ Bê°€ nìœ¼ë¡œ ë‚˜ëˆ„ì—ˆì„ ë•Œ ë‚˜ë¨¸ì§€ê°€ ê°™ë‹¤ë©´ Aì™€ BëŠ” ëª¨ë“ˆ Cì— ëŒ€í•œ í•©ë™ ê´€ê³„ë¼ê³  í•œë‹¤
- ê·¸ëŸ¬í•œ Aì™€ BëŠ” A - Bë¥¼ í•˜ì˜€ì„ ë•Œ k*nê³¼ ê°™ë‹¤
- ì¦‰, A - B = knìœ¼ë¡œ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆë‹¤
<br/>

#### 2) ëª¨ë“ˆëŸ¬ ì—°ì‚°ì˜ ì†ì„±
1. (a + b) mod n = ((a mod n) + (b mod n)) mod n
2. (a - b) mod n = ((a mod n) - (b mod n)) mod n
<br/>

ì¶œì²˜: https://www.crocus.co.kr/1231 [Crocus]
