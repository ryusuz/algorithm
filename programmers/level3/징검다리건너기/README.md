# [Level3] 징검다리 건너기

https://programmers.co.kr/learn/courses/30/lessons/64062

</br>

## ✏️ 풀이 방법
징검다리를 건널 때마다 확인하는 방법도 있지만 이러면 효율성이 떨어져 시간초과가 난다.

원소의 값은 최대 2억, 돌의 개수는 20만개이기 때문에 더 효율적인 알고리즘을 사용해야한다.

이렇게 무지하게 큰 숫자가 나오면 ⭐️**이분탐색**⭐️ 알고리즘 사용하기!!!!!

뭐를 기준으로 이분탐색하는가? => **징검다리를 건너는 사람의 수**

최대로 건널 수 있는 사람의 수는 stones에서 가장 큰 값과 같다.

1. stones에서 가장 큰 값 구하고 이 값을 end로 설정, start는 1
2. start <= end 동안 아래를 3~6을 반복한다.
3. mid = start + end / 2
4. stones를 돌면서 각 원소에 mid를 뺀 값이 0과 같거나 작다면 카운트++
5. 카운트 >= k 이면 못 건넌다는 뜻. => end 값을 하나 줄여준다. (건널 수 있는 사람 수 줄임)
6. 그게 아니면 건널 수 있다. => start 값을 하나 늘려준다. (건널 수 있는 사람 수 늘림)
7. return start (or return end) => 어차피 start == end여야 반복문이 끝나니까 상관 x

<br/>

## 💡 이분탐색 알고리즘
예를 들어 배열 안에 특정 수를 찾는다! 한다면

배열을 **오름차순으로 정렬** 후, 가운데 인덱스에 있는 원소를 확인해서 특정 수보다 작으면 왼쪽을 탐색, 크면 오른쪽을 탐색한다.

이 문제에서는 건널 수 있는 사람의 숫자를 기준으로 이분탐색하기 때문에 stones 자체는 정렬하지 않는다.

start ~ end, 즉 1부터 가장 큰 값까지 1씩 더해주거나 빼주기 때문에 정렬되어있는 것과 마찬가지.

